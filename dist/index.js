"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("libsodium-wrappers"),a=(e=require("axios"))&&"object"==typeof e&&"default"in e?e.default:e,s=require("phoenix"),n={generateRandom:(e=16)=>window.crypto.getRandomValues(new Uint8Array(e)),async getHash(e,a=""){await t.ready;const s=await window.crypto.subtle.digest("SHA-256",Buffer.from(e+a));return t.to_hex(Buffer.from(s))},async deriveKey(e,a){await t.ready;const s=await window.crypto.subtle.importKey("raw",Buffer.from(e),"PBKDF2",!1,["deriveBits","deriveKey"]),n=await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:Buffer.from(a)||this.generateRandom(),iterations:1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:128},!0,["encrypt","decrypt"]);return await this.exportKey(n)},async generateKey(){const e=await window.crypto.subtle.generateKey({name:"AES-GCM",length:128},!0,["encrypt","decrypt"]);return this.exportKey(e)},async exportKey(e,a="raw"){await t.ready;const s=await window.crypto.subtle.exportKey(a,e);return t.to_base64(Buffer.from(s))},async importKey(e){await t.ready;const a=t.from_base64(e);return await window.crypto.subtle.importKey("raw",a,{name:"AES-GCM"},!0,["encrypt","decrypt"])},async encrypt(e,a){await t.ready;const s=await this.importKey(e),n=this.generateRandom(12),r=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:n},s,t.from_string(a));return`${t.to_base64(n)}@${t.to_base64(Buffer.from(r))}`},async decrypt(e,a){await t.ready;const s=await this.importKey(e);a=a.split("@");const n=t.from_base64(a[0]),r=t.from_base64(a[1]),i=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:n},s,r);return t.to_string(i)}},r={generateAppKeys:async()=>({appKey:await n.generateKey(),appSalt:await n.generateKey()}),async generateAppKeysPackage(e,t=null){const a=await n.generateKey(),s=await n.deriveKey(e,a);t=t||await this.generateAppKeys();return{keyPackage:await n.encrypt(s,JSON.stringify(t)),appKeys:t,appKeySalt:a}}},i={authenticate:async(e,t)=>(await a.post(process.env.VUE_APP_BACKEND_URL+"/auth",{email:e,password:await n.deriveKey(t,"passwordSalt")})).data,createUserToken:async e=>(await a.post(process.env.VUE_APP_BACKEND_URL+"/auth/registration",{email:e})).data,async createUser(e,t,s,i){const o=await r.generateAppKeysPackage(s);return(await a.post(process.env.VUE_APP_BACKEND_URL+"/auth/registration",{token:e,user:{email:t,password:await n.deriveKey(s,"passwordSalt"),password_hint:i,appkey:o.keyPackage,appkey_salt:o.appKeySalt}})).data}};exports.ItemChannel=class{constructor(){this.email=null,this.pass=null,this.accountId=null,this.token=null,this.appkey=null,this.appkeySalt=null}async connect(e,t){this.email=e,this.pass=t;const a=await i.authenticate(e,t);return this.token=a.token,this.accountId=a.account_id,this.userKey=await n.deriveKey(t,a.appkey_salt),this.appKeysPackage=JSON.parse(await n.decrypt(this.userKey,a.appkey)),this.socket=new s.Socket(process.env.VUE_APP_WS_URL+"/socket",{params:{token:this.token}}),this.socket.connect(),this.channel=this.socket.channel("item:"+this.accountId),this.channel.on("all_items",e=>{console.log("Receiving all items!",e)}),this.channel.join().receive("ok",e=>{console.log("OK all items!",e)}),this.channel}async create(e,t="item"){const a=await n.encrypt(this.appKeysPackage.appKey,JSON.stringify(e)),s=await n.getHash(t,this.appKeysPackage.appSalt);return this.channel.push("add_item",{item:{content:a,content_type:s}})}async update(e,t,a){const s=await n.encrypt(this.appKeysPackage.appKey,JSON.stringify(t)),r=await n.getHash(a,this.appKeysPackage.appSalt);return t={content:s},a&&(t.content_type=r),this.channel.push("update_item",{id:e,item:t})}async delete(e){return this.channel.push("delete_item",{id:e})}},exports.crypto=n,exports.user=r,exports.userClient=i;
